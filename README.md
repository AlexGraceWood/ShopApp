SOLID, DRY and Magic Numbers
SRP (Single Responsibility Principle):
1.	public class Product:
o	Отвечает за хранение данных о продукте.
o	Описывает свойства продукта (название, производитель, цена, рейтинг) и предоставляет методы для работы с ними (например, добавление рейтинга).
2.	public class ProductService:
o	Управляет списком товаров.
o	Реализует методы для добавления товаров, фильтрации и рекомендаций на основе рейтинга.
o	Не занимается логикой заказов или корзины, что отделяет его ответственность.
3.	public class Cart:
o	Отвечает за хранение товаров, добавленных пользователем в корзину.
o	Позволяет добавлять, удалять товары и вычислять общую стоимость товаров в корзине.
o	Не включает логики обработки заказов или управления товарами, что соответствует принципу SRP.
4.	public class Order:
o	Хранит информацию о заказе, включая уникальный идентификатор, список продуктов и статус заказа.
o	Обеспечивает методы для получения информации о заказе и изменения его статуса.
5.	public class OrderService:
o	Управляет процессом размещения, отслеживания, возврата и повторения заказов.
o	Отделён от логики, связанной с корзиной или продуктами, и работает только с объектами типа Order.
6.	public class ShopApp (главный класс):
o	Отвечает за взаимодействие с пользователем через консоль.
o	Координирует работу других классов, направляя действия пользователя к соответствующему функционалу (например, добавление товара в корзину или размещение заказа).
o	Сам не управляет продуктами, корзиной или заказами напрямую, а делегирует задачи соответствующим сервисам.

OCP (Open/Closed Principle):
Система фильтрации легко расширяется добавлением новых условий фильтрации без изменения кода ProductService.       
(См. метод filterProducts.) Чтобы добавить новый фильтр, например фильтрацию по рейтингу, не нужно менять метод filterProducts. Достаточно передать новый параметр (например, минимальный рейтинг) и добавить ещё одно условие в цепочку фильтрации
LSP (Liskov Substitution Principle):
Класс OrderService отвечает за управление заказами: создание, отслеживание, возврат и повторение заказов. Его функциональность базируется на стандартных структурах данных, таких как HashMap для хранения заказов. Если в будущем потребуется использовать другую реализацию для управления заказами, например, базу данных или удалённое API, мы можем заменить OrderService другим классом с той же функциональностью. Например, DatabaseOrderService. Код в ShopApp не изменится, потому что он зависит от интерфейса (или базового класса) OrderService, а не от конкретной реализации. Пример: 
OrderService orderService = new DatabaseOrderService();

DIP (Dependency Inversion Principle):
Зависимости между классами передаются через конструкторы (или методы), а не создаются внутри самих классов. Это делает классы более гибкими, модульными и тестируемыми. В классе ShopApp, который управляет взаимодействием с пользователем, используются следующие зависимости:
•	ProductService — для управления товарами.
•	Cart — для работы с корзиной.
•	OrderService — для управления заказами.
DRY:
Логика фильтрации и подсчета общей суммы избегает дублирования благодаря использованию стримов.
(См. метод calculateTotal в Cart и filterProducts в ProductService) 
Стримы позволяют легко применять операции над коллекциями, такие как фильтрация, преобразование или суммирование, не создавая при этом много промежуточного кода.
Magic Numbers
В первом коммите проекта (Initial Commit) были умышленно использованы «магические числа» при добавлении рейтинга в классе ShopApp и в методе recommendProducts() в классе ProductService. В коммите Magic Numbers эти магические числа были заменены константами с осмысленными именами

